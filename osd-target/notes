#vim : ft=cfg

IMPORTANT
append
create
create and write
create collection
create partition
read
read buffer
write
write buffer
list
list collection
format osd
get attributes
set attributes
remove
remove collection
remove partition
report luns
set key
set master key

inquiry
flush
flush collection
flush osd
flush partition
receive diagnostic results
report supported operation codes


NOT IMPLEMENTED/OPTIONAL
log select
log sense
mode select
mode sense
perform scsi command
perform task management function
persistent reserve in
persistent reserve out
prevent allow medium removal
report supported task management functions
report target port groups
request sense
send diagnostic
set target port groups
test unit ready

directory pages
quotas

========================================
root object
	partition
		collection
		object
		or any osd object type


questions:
-	how to create osd? flat file? what will be blocks?
-	how is collection populated?
-	where will be attributes stored for an object?
-	

design:
	root directory for the root object
	each partition is a directory within the root directory
	objects are stored within the partition
	collection objects are stored within the directory

db requirements:
	get all attr for an oid
	get all attr for an oid in an attr page
	get an attr for an oid on an attr page
	set an attr on oid on an attr page
	for an oid check for duplicate attr numbers
	check for duplicate attr pages across attr types

solution:
	use one db file per object storing is attr
	don't allow attribute pages beyond F000 0000h
	restrict attribute pages in range as specified in p22
	get all attr using db cursor
	use environment to store database of multiple objects



# Wed Dec  6 11:54:17 EST 2006
What is the meaning of the following (p21):

With the exception of attributes pages in the attributes page number range
assigned to any OSD object types, the same attributes page shall not be
associated with more than one OSD object type.
Two object types cannot share same page number but two objects can.

#if 0 /* > 3.8.8 of sqlite */
	ret = sqlite3_extended_result_codes(dbp, 1);
	if (ret != SQLITE_OK) {
		fprintf(stderr, "SQL ERROR: %s\n", sqlite3_errmsg(dbp));
		return -1;
	}
#endif

# Mon Jan 22 12:15:56 EST 2007
prepare functions for most used sql stmt. look at reset, since bound var
still retain their values.
get_all_attr in a page
move create partition to obfs.c
remove delete object code from attr
rename attr-* to attr.c
change uint64_t to use typedefs
mv db code to db.c
mv tab code to obj.c and attr.c
mv obfs to osd
rm init_attr, use attr_t with len = 0;
clean finalize code

-	p23, attr number FFFFFFFFh gets all attr for a page
-	p23, p87, p112: No explicit call to delete an object's attribute. only
	thing possible is to set an attribute's length to 0. Since only
	attributes with non-zero length can be retrieved.

# Tue Jan 23 11:59:47 EST 2007
remove attr_insert and attr_delete. 
change set_attr properly
obj: insert, delete works
attr: 
	set_attr -> check if attr exists, if so update else insert it
	get_attr -> select attr, if empty EEMPTY
	delete_attr -> delete all attr for object
	get_attr_page -> get all attr in a page

define return values, we return same return values as sqlite or should
we assume this is single threaded app => no table locking, no checking for
EBUSY. in future keep sqlite3_step in a infinite loop

# Fri Jan 26 11:03:52 EST 2007
- 	put sqlite_step statemnts in infinite loop.
-	consistent return codes
-	single makefile for tests and libosd
-	make rules for dependencies
-	defines for ROOT_OBJECT, ROOT_PARTITION
-	osd_device to osd_hndl
-	change obj tab, include type of object being created

# Mon Jan 29 12:39:02 EST 2007
-	prepare frequently used statements and store them. Make a list of
	potential optimizations.
-	what is current commands attr page
-	sense_* functions are not up to date. osd_* are not returning correct
	values.
-	loosing return value due to finalize
-	collect all errors using goto

# Tue Jan 30 16:12:47 EST 2007
schema changes. attr table need to have directory pages. rows need to have
writable flags to prevent certain directory pages to be modified. directories
can be implemented as a sql view on page numbers 0
