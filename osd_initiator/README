Documentation for initiator library.

There are five major files here, each of which has a separate header
file that can be included from user programs:

	- drivelist
	- device
	- command
	- sense
	- sync


Drivelist
---------
These two functions are used to get and free a list of available OSD
drives:

int osd_get_drive_list(struct osd_drive_description **drives, int *num_drives);
void osd_free_drive_list(struct osd_drive_description *drives, int num_drives);

It works by querying the SCSI interface.  Data is allocated and returned
into the given pointer, so another call is used to free the data when
done with it.  In the struct that is returned are two fields:
targetname, and chardev.  Pass the chardev to open() to open a device.


Device
------
Given an fd to an open device, this set of routines is used to submit
commands and wait for responses.


Command
-------
This is the element that encapsulates all information about an OSD
command, including attributes, in- and out-data, and sense results.
The various calls can build a command, which can then be given to one
of the device functions to submit.  After completion, output fields
in the command structure can be inspected.

To start, the user allocates a struct osd_command, perhaps on the
stack, and passes a pointer to it to one of the 29 osd_command_set_*
calls.  These each clear the command and set up fields appropriately
for the SCSI command.

Next, if the command requires data, like a write, set this in the
command.  For a single buffer,

	command->outdata = buf;
	command->outlen = len;

Make sure to keep the buffer around until the command completes, i.e.
the data is not copied.  For a vector of data, you must build an iovec
and assign that to outdata.

	struct bsg_iovec vec[2] = {
		{ .iov_base = (uintptr_t) buf1, .iov_len = len1 },
		{ .iov_base = (uintptr_t) buf2, .iov_len = len2 },
	};
	command->outdata = vec;
	command->outlen = len1 + len2;
	command->iov_outlen = 2;

If the command is expected to return data, you must set up a buffer
for the maximum size response.  For a single buffer,

	command->indata = buf;
	command->inlen_alloc = len;

After the command completes, check command->inlen to see the actual
size of data returned.  For example, reading an object will only return
the number of bytes in the object regardless of how much you ask for.

The next step, after initializing the command and setting up the data
pointers, is to attach any attributes.  This must be done after setting
the data pointers as it will modify those fields in the command.  Make
a single call to the attribute build function, passing it an array of
structures that describe the attributes of interest.  For example,

	uint64_t logical_len;
	char owner[20];
	const char data[] = "Some data.";
	struct attribute_list attr[] = {
		{ .type = ATTR_GET, .page = 0x82, .number = 1,
		  .val = &logical_len, .len = 8 },
		{ .type = ATTR_GET, .page = 0x10993, .number = 12,
		  .val = owner, .len = 20 },
		{ .type = ATTR_SET, .page = 0x10076, .number = 1,
		  .val = data, .len = sizeof(data) },
	};
	osd_command_attr_build(command, attr, 3);

For GET attributes, provide a pointer to where to put the data when
the command executes.  For PUT attributes, provide the input data.
The attribute structure and output data pointers must remain valid
until the attributes are resolved, after execution.  The input data
is copied during this build phase.  Internally a single allocation
holds the various structures required by the OSD and will be freed
during osd_command_attr_resolve.

Now, run the command using the device interface:

	osd_submit_command(fd, command);

And wait for it to complete

	osd_wait_this_response(fd, command);

Before the data or the GET attributes can be accessed, a call to
resolve the attributes must be made to move the resulting buffers
around:

	osd_command_attr_resolve(command, attr, 3)

Now it is safe to look at logical_len and owner, e.g.  But don't
forget to do ntohll() on things that look like integers.  You can
also check attr[1].outlen to see if the actual string is 20 bytes
long.  It is also now safe to look at the data in command->indata.

It is not necessary to free anything other than the command and
attribute structures, if you allocated them on the heap.


Sense
-----
One single call returns a descriptive string for an error.  If, after
executing a command, the command->status field is 2 (CHECK_CONDITION),
call:

	s = osd_show_sense(command->sense, command->sense_len);

then print s as an error, and free it when done.


Sync
----
This collection of synchronous routines is very handy for testing and
for most programs.  These functions are mostly analogous to the ones
in command.h, but they setup a command, run it, check the results, and
return data all in one step.  For example

	create_partition(fd, 0);

creates a new partitition.  Internally it makes three calls to command.h
with lots of error checking.

