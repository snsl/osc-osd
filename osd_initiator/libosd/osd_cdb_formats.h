/*************************************************************
** Copyright 2004, 2005. IBM Corp.** All Rights Reserved.***
**************************************************************
** Redistribution and use in source and binary forms, with or without
** modifications, are permitted provided that the following conditions 
** are met:
** 
** i.  Redistribution of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**
** ii. Redistribution in binary form must reproduce the above copyright 
**     notice, this list of conditions and the following disclaimer in the 
**     documentation and/or other materials provided with the distribution.
**
** iii.Neither the name(s) of IBM Corp.** nor the names of its/their
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
*******************************************************************
** THIS SOFTWARE IS PROVIDED BY IBM CORP. AND CONTRIBUTORS "AS IS" 
** AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING , BUT NOT LIMITED
** TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
** PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE IBM
** CORP. OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
** (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
** STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
** OF THE POSSIBILITY OF SUCH DAMAGE.
** 
*****************************************************************************
*****************************************************************************/
/* This File was automatically generated by script gawk
 * source file: ../src/t10/osd/osd_cdb_formats.src.
 * generation time:Mon Aug 29 06:40:46 EDT 2005
 */
//File: ../obj/osd_cdb_formats_h.tmp

#ifndef OSD_CDB_FORMATS_H
#define OSD_CDB_FORMATS_H
////////////////////////////////////////////
//first part general definitions for formats

////////////////////////////////////////////
// second part - for each struct defined
// c-struct, constants, encap/decap prototype

///***************************** start_copyright_notice_OCO_2005	
// * IBM Confidential
// * OCO Source Materials
// * (C) Copyright IBM Corp. 2005
// * The source code for this program is not published or otherwise
// * divested of its trade secrets, irrespective of what has
// * been deposited with the U.S. Copyright Office.
//end_copyright_notice_OCO_2005
// ***********************************************************/
// todos compared to alons version
// set nullable
// set virtual
// others: set initial_value, is_mutable
// this is a source file for gen_formats.swk script which generates
// formats code according to this file.
// syntax and directions for use:
// this file is used to define 3 types of structures:
//  A.non-attributes fixed size standard structure (e.g. cdb header)
//  B.fixed-size attribute page (with only fixed size attributes)
//  C.variable-size attribute page (with at least one var-size attribute)
//
// the three types are defined using same syntax for definition
// but one should define each type by it's directions:
//general syntax
// each statement is in a different line.
// ';' at end of line can be used and is ignored
//  line beginning with '//' is copied to generated h file
// statements should be in the following form:
//
// struct <name> {
//   size nnn|NUM_EMPTY - NUM EMPTY used for var-size structures only
//   [num <num-expression may include spaces>] - used in attribute pages
//         num expression can use PAGE_R/PAGE_C/PAGE_P constants
//   [vendor vendor-codename] - in attribute pages only	   
//                            - default codename is INCITS
//   field <type> <name> {
//     (valid types: uint8_t,uint16_t,uint32_t,uint64_t,offset32_t,time48_t}
//     [num <num expression>|NUM_EMPTY] - used for attributes
//     [access <access_type>] - used for attributes
//       (valid access types: 
//	 OSD_ATTR_NO_ACCESS, (default if not specified)
//	 OSD_ATTR_OSD_RD, osd supplied. read only
//	 OSD_ATTR_OSD_RW, osd supplied. read/write
//	 OSD_ATTR_USER_RW not osd supplied. read/write
//     size 0|nnnn - size in bytes. 0 marks var-size attribute
//     [offset nnn] - used in fixed size structures.
//   }
//}
// for attributes note thatt c defines fill get names
// including concatenation of 10 letter prefix,struct name,field name
// so names ahd better be no longer than 15 chars
// A. directions for non attribute standard struct :
// 1. don't use the 'num' and 'access' statements
// 2.use UPPER_CASE for struct name and lower case for field names.
// (lettercase is for convenience only - not a real syntax requirement)
// 3.specify size for struct
//   for each field specifi a nonzero size and the correct offset 
//   sizes and offsets are checked by script
// B. directions for fixed size attribute page :
// 1. specify the 'num' statement for struct and each attribute in it.
// 2. specify access type for each field.
// 3. use UPPER_CASE for both page name and attribute names.
// (lettercase is for convenience only - not a real syntax requirement)
// 4. specify size for struct
//    for each field specify a nonzero size and the correct offset 
//    sizes and offsets are checked by script
// C. directions for variable size attribute page :
// 1. specify the 'num' statement for struct and each attribute in it.
// 2. specify access type for each field.
// 3. use UPPER_CASE for both page name and attribute names.
// (lettercase is for convenience only - not a real syntax requirement)
// 4. specify 'size NUM_EMPTY' for struct
//    for each field specify  'size <nnn>' (nnn=0 for var-size attribute) 
// 5. don't use 'offset' statement
///////////////////////////////////////////////////////////////////////////
////////////////////////////////////
// CDB formats:
#define OSD_STRUCT_CDB_HDR (&(gen_structs[0]))
//defines first 12 bytes of cdb in osd commands

#define OSD_FIELD_CDB_HDR_opcode (&(gen_structs[0].fields[0])) 
#define OSD_FIELD_CDB_HDR_control (&(gen_structs[0].fields[1])) 
#define OSD_FIELD_CDB_HDR_reserved1 (&(gen_structs[0].fields[2])) 
#define OSD_FIELD_CDB_HDR_additional_length (&(gen_structs[0].fields[3])) 
	//for osd commands 1st byte should be 0x88
#define OSD_FIELD_CDB_HDR_service_action (&(gen_structs[0].fields[4])) 
#define OSD_FIELD_CDB_HDR_options_byte1 (&(gen_structs[0].fields[5])) 
#define OSD_FIELD_CDB_HDR_options_byte2 (&(gen_structs[0].fields[6])) 
#define OSD_FIELD_CDB_HDR_timestamp_ctl (&(gen_structs[0].fields[7])) 

typedef struct {
    uint8_t opcode;
    uint8_t control;
    uint8_t reserved1[5];
    uint8_t additional_length;
    uint16_t service_action;
    uint8_t options_byte1;
    uint8_t options_byte2;
    uint8_t timestamp_ctl;
    PACKED_STRUCT_END;
} PACKED OSD_CDB_HDR_t;

#define SIZEOF_OSD_CDB_HDR_t 13 
static inline void GENERIC_ENCAP_CDB_HDR(
    OSD_CDB_HDR_t *dst,
    uint8_desc_t src_opcode, 
    uint8_desc_t src_control, 
    uint8_desc_t src_additional_length, 
    uint16_desc_t src_service_action, 
    uint8_desc_t src_options_byte1, 
    uint8_desc_t src_options_byte2, 
    uint8_desc_t src_timestamp_ctl )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CDB_HDR_t));
    UINT8_ENCAP((dst->opcode), src_opcode);
    UINT8_ENCAP((dst->control), src_control);
    //memset((void*)(&(dst->reserved1)),0,5);
    UINT8_ENCAP((dst->additional_length), src_additional_length);
    UINT16_ENCAP((dst->service_action), src_service_action);
    UINT8_ENCAP((dst->options_byte1), src_options_byte1);
    UINT8_ENCAP((dst->options_byte2), src_options_byte2);
    UINT8_ENCAP((dst->timestamp_ctl), src_timestamp_ctl);
}

static inline void GENERIC_DECAP_CDB_HDR(
    const OSD_CDB_HDR_t *src,
    uint8_desc_t *dst_opcode, 
    uint8_desc_t *dst_control, 
    uint8_desc_t *dst_additional_length, 
    uint16_desc_t *dst_service_action, 
    uint8_desc_t *dst_options_byte1, 
    uint8_desc_t *dst_options_byte2, 
    uint8_desc_t *dst_timestamp_ctl)
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CDB_HDR_t));
    osd_assert(dst_opcode);
    UINT8_DECAP((src->opcode), (*dst_opcode));
    osd_assert(dst_control);
    UINT8_DECAP((src->control), (*dst_control));
    osd_assert(dst_additional_length);
    UINT8_DECAP((src->additional_length), (*dst_additional_length));
    osd_assert(dst_service_action);
    UINT16_DECAP((src->service_action), (*dst_service_action));
    osd_assert(dst_options_byte1);
    UINT8_DECAP((src->options_byte1), (*dst_options_byte1));
    osd_assert(dst_options_byte2);
    UINT8_DECAP((src->options_byte2), (*dst_options_byte2));
    osd_assert(dst_timestamp_ctl);
    UINT8_DECAP((src->timestamp_ctl), (*dst_timestamp_ctl));
}

static inline void GENERIC_PRINT_CDB_HDR( const OSD_CDB_HDR_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    UINT8_PRINT(0, "opcode", (src->opcode));
CHECK_OFS(src, &(src->opcode),0);    UINT8_PRINT(1, "control", (src->control));
CHECK_OFS(src, &(src->control),1);    UINT8_PRINT(7, "additional_length", (src->additional_length));
CHECK_OFS(src, &(src->additional_length),7);    UINT16_PRINT(8, "service_action", (src->service_action));
CHECK_OFS(src, &(src->service_action),8);    UINT8_PRINT(10, "options_byte1", (src->options_byte1));
CHECK_OFS(src, &(src->options_byte1),10);    UINT8_PRINT(11, "options_byte2", (src->options_byte2));
CHECK_OFS(src, &(src->options_byte2),11);    UINT8_PRINT(12, "timestamp_ctl", (src->timestamp_ctl));
CHECK_OFS(src, &(src->timestamp_ctl),12);}



#define OSD_STRUCT_CDB_ATTR_LIST (&(gen_structs[1]))
    // defines structure of bytes 52..79 in cdb when accessing
    // attributes in list format+

#define OSD_FIELD_CDB_ATTR_LIST_reserved0 (&(gen_structs[1].fields[0])) 
#define OSD_FIELD_CDB_ATTR_LIST_get_list_length (&(gen_structs[1].fields[1])) 
#define OSD_FIELD_CDB_ATTR_LIST_get_list_dout_offset (&(gen_structs[1].fields[2])) 
#define OSD_FIELD_CDB_ATTR_LIST_get_allocation_length (&(gen_structs[1].fields[3])) 
#define OSD_FIELD_CDB_ATTR_LIST_retrieved_attr_din_offset (&(gen_structs[1].fields[4])) 
#define OSD_FIELD_CDB_ATTR_LIST_set_list_length (&(gen_structs[1].fields[5])) 
#define OSD_FIELD_CDB_ATTR_LIST_set_list_dout_offset (&(gen_structs[1].fields[6])) 
#define OSD_FIELD_CDB_ATTR_LIST_reserved1 (&(gen_structs[1].fields[7])) 

typedef struct {
    uint8_t reserved0[52];
    uint32_t get_list_length;
    offset32_t get_list_dout_offset;
    uint32_t get_allocation_length;
    offset32_t retrieved_attr_din_offset;
    uint32_t set_list_length;
    offset32_t set_list_dout_offset;
    uint8_t reserved1[4];
    PACKED_STRUCT_END;
} PACKED OSD_CDB_ATTR_LIST_t;

#define SIZEOF_OSD_CDB_ATTR_LIST_t 80 
static inline void GENERIC_ENCAP_CDB_ATTR_LIST(
    OSD_CDB_ATTR_LIST_t *dst,
    uint32_desc_t src_get_list_length, 
    offset32_desc_t src_get_list_dout_offset, 
    uint32_desc_t src_get_allocation_length, 
    offset32_desc_t src_retrieved_attr_din_offset, 
    uint32_desc_t src_set_list_length, 
    offset32_desc_t src_set_list_dout_offset )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CDB_ATTR_LIST_t));
    //memset((void*)(&(dst->reserved0)),0,52);
    UINT32_ENCAP((dst->get_list_length), src_get_list_length);
    OFFSET32_ENCAP((dst->get_list_dout_offset), src_get_list_dout_offset);
    UINT32_ENCAP((dst->get_allocation_length), src_get_allocation_length);
    OFFSET32_ENCAP((dst->retrieved_attr_din_offset), src_retrieved_attr_din_offset);
    UINT32_ENCAP((dst->set_list_length), src_set_list_length);
    OFFSET32_ENCAP((dst->set_list_dout_offset), src_set_list_dout_offset);
    //memset((void*)(&(dst->reserved1)),0,4);
}

static inline void GENERIC_DECAP_CDB_ATTR_LIST(
    const OSD_CDB_ATTR_LIST_t *src,
    uint32_desc_t *dst_get_list_length, 
    offset32_desc_t *dst_get_list_dout_offset, 
    uint32_desc_t *dst_get_allocation_length, 
    offset32_desc_t *dst_retrieved_attr_din_offset, 
    uint32_desc_t *dst_set_list_length, 
    offset32_desc_t *dst_set_list_dout_offset)
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CDB_ATTR_LIST_t));
    osd_assert(dst_get_list_length);
    UINT32_DECAP((src->get_list_length), (*dst_get_list_length));
    osd_assert(dst_get_list_dout_offset);
    OFFSET32_DECAP((src->get_list_dout_offset), (*dst_get_list_dout_offset));
    osd_assert(dst_get_allocation_length);
    UINT32_DECAP((src->get_allocation_length), (*dst_get_allocation_length));
    osd_assert(dst_retrieved_attr_din_offset);
    OFFSET32_DECAP((src->retrieved_attr_din_offset), (*dst_retrieved_attr_din_offset));
    osd_assert(dst_set_list_length);
    UINT32_DECAP((src->set_list_length), (*dst_set_list_length));
    osd_assert(dst_set_list_dout_offset);
    OFFSET32_DECAP((src->set_list_dout_offset), (*dst_set_list_dout_offset));
}

static inline void GENERIC_PRINT_CDB_ATTR_LIST( const OSD_CDB_ATTR_LIST_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    UINT32_PRINT(52, "get_list_length", (src->get_list_length));
CHECK_OFS(src, &(src->get_list_length),52);    OFFSET32_PRINT(56, "get_list_dout_offset", (src->get_list_dout_offset));
CHECK_OFS(src, &(src->get_list_dout_offset),56);    UINT32_PRINT(60, "get_allocation_length", (src->get_allocation_length));
CHECK_OFS(src, &(src->get_allocation_length),60);    OFFSET32_PRINT(64, "retrieved_attr_din_offset", (src->retrieved_attr_din_offset));
CHECK_OFS(src, &(src->retrieved_attr_din_offset),64);    UINT32_PRINT(68, "set_list_length", (src->set_list_length));
CHECK_OFS(src, &(src->set_list_length),68);    OFFSET32_PRINT(72, "set_list_dout_offset", (src->set_list_dout_offset));
CHECK_OFS(src, &(src->set_list_dout_offset),72);}



#define OSD_STRUCT_CDB_ATTR_PAGE (&(gen_structs[2]))
    // defines structure of bytes 52..79 in cdb when accessing
    // attributes in page format

#define OSD_FIELD_CDB_ATTR_PAGE_reserved0 (&(gen_structs[2].fields[0])) 
#define OSD_FIELD_CDB_ATTR_PAGE_get_page_num (&(gen_structs[2].fields[1])) 
#define OSD_FIELD_CDB_ATTR_PAGE_get_allocation_length (&(gen_structs[2].fields[2])) 
#define OSD_FIELD_CDB_ATTR_PAGE_retrieved_attr_din_offset (&(gen_structs[2].fields[3])) 
#define OSD_FIELD_CDB_ATTR_PAGE_set_page_num (&(gen_structs[2].fields[4])) 
#define OSD_FIELD_CDB_ATTR_PAGE_set_attr_num (&(gen_structs[2].fields[5])) 
#define OSD_FIELD_CDB_ATTR_PAGE_set_attr_length (&(gen_structs[2].fields[6])) 
#define OSD_FIELD_CDB_ATTR_PAGE_set_attr_dout_offset (&(gen_structs[2].fields[7])) 

typedef struct {
    uint8_t reserved0[52];
    uint32_t get_page_num;
    uint32_t get_allocation_length;
    offset32_t retrieved_attr_din_offset;
    uint32_t set_page_num;
    uint32_t set_attr_num;
    uint32_t set_attr_length;
    offset32_t set_attr_dout_offset;
    PACKED_STRUCT_END;
} PACKED OSD_CDB_ATTR_PAGE_t;

#define SIZEOF_OSD_CDB_ATTR_PAGE_t 80 
static inline void GENERIC_ENCAP_CDB_ATTR_PAGE(
    OSD_CDB_ATTR_PAGE_t *dst,
    uint32_desc_t src_get_page_num, 
    uint32_desc_t src_get_allocation_length, 
    offset32_desc_t src_retrieved_attr_din_offset, 
    uint32_desc_t src_set_page_num, 
    uint32_desc_t src_set_attr_num, 
    uint32_desc_t src_set_attr_length, 
    offset32_desc_t src_set_attr_dout_offset )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CDB_ATTR_PAGE_t));
    //memset((void*)(&(dst->reserved0)),0,52);
    UINT32_ENCAP((dst->get_page_num), src_get_page_num);
    UINT32_ENCAP((dst->get_allocation_length), src_get_allocation_length);
    OFFSET32_ENCAP((dst->retrieved_attr_din_offset), src_retrieved_attr_din_offset);
    UINT32_ENCAP((dst->set_page_num), src_set_page_num);
    UINT32_ENCAP((dst->set_attr_num), src_set_attr_num);
    UINT32_ENCAP((dst->set_attr_length), src_set_attr_length);
    OFFSET32_ENCAP((dst->set_attr_dout_offset), src_set_attr_dout_offset);
}

static inline void GENERIC_DECAP_CDB_ATTR_PAGE(
    const OSD_CDB_ATTR_PAGE_t *src,
    uint32_desc_t *dst_get_page_num, 
    uint32_desc_t *dst_get_allocation_length, 
    offset32_desc_t *dst_retrieved_attr_din_offset, 
    uint32_desc_t *dst_set_page_num, 
    uint32_desc_t *dst_set_attr_num, 
    uint32_desc_t *dst_set_attr_length, 
    offset32_desc_t *dst_set_attr_dout_offset)
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CDB_ATTR_PAGE_t));
    osd_assert(dst_get_page_num);
    UINT32_DECAP((src->get_page_num), (*dst_get_page_num));
    osd_assert(dst_get_allocation_length);
    UINT32_DECAP((src->get_allocation_length), (*dst_get_allocation_length));
    osd_assert(dst_retrieved_attr_din_offset);
    OFFSET32_DECAP((src->retrieved_attr_din_offset), (*dst_retrieved_attr_din_offset));
    osd_assert(dst_set_page_num);
    UINT32_DECAP((src->set_page_num), (*dst_set_page_num));
    osd_assert(dst_set_attr_num);
    UINT32_DECAP((src->set_attr_num), (*dst_set_attr_num));
    osd_assert(dst_set_attr_length);
    UINT32_DECAP((src->set_attr_length), (*dst_set_attr_length));
    osd_assert(dst_set_attr_dout_offset);
    OFFSET32_DECAP((src->set_attr_dout_offset), (*dst_set_attr_dout_offset));
}

static inline void GENERIC_PRINT_CDB_ATTR_PAGE( const OSD_CDB_ATTR_PAGE_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    UINT32_PRINT(52, "get_page_num", (src->get_page_num));
CHECK_OFS(src, &(src->get_page_num),52);    UINT32_PRINT(56, "get_allocation_length", (src->get_allocation_length));
CHECK_OFS(src, &(src->get_allocation_length),56);    OFFSET32_PRINT(60, "retrieved_attr_din_offset", (src->retrieved_attr_din_offset));
CHECK_OFS(src, &(src->retrieved_attr_din_offset),60);    UINT32_PRINT(64, "set_page_num", (src->set_page_num));
CHECK_OFS(src, &(src->set_page_num),64);    UINT32_PRINT(68, "set_attr_num", (src->set_attr_num));
CHECK_OFS(src, &(src->set_attr_num),68);    UINT32_PRINT(72, "set_attr_length", (src->set_attr_length));
CHECK_OFS(src, &(src->set_attr_length),72);    OFFSET32_PRINT(76, "set_attr_dout_offset", (src->set_attr_dout_offset));
CHECK_OFS(src, &(src->set_attr_dout_offset),76);}



#define OSD_STRUCT_CDB_SEC_PARAMS (&(gen_structs[3]))
    //describes offsets 80-200 in CDB

#define OSD_FIELD_CDB_SEC_PARAMS_reserved0 (&(gen_structs[3].fields[0])) 
#define OSD_FIELD_CDB_SEC_PARAMS_capability (&(gen_structs[3].fields[1])) 
#define OSD_FIELD_CDB_SEC_PARAMS_req_int_chk_val (&(gen_structs[3].fields[2])) 
#define OSD_FIELD_CDB_SEC_PARAMS_req_nonce (&(gen_structs[3].fields[3])) 
#define OSD_FIELD_CDB_SEC_PARAMS_din_int_chk_ofs (&(gen_structs[3].fields[4])) 
#define OSD_FIELD_CDB_SEC_PARAMS_dout_int_chk_ofs (&(gen_structs[3].fields[5])) 

typedef struct {
    uint8_t reserved0[80];
    uint8_t capability[80];
    uint8_t req_int_chk_val[20];
    array12_t req_nonce;
    offset32_t din_int_chk_ofs;
    offset32_t dout_int_chk_ofs;
    PACKED_STRUCT_END;
} PACKED OSD_CDB_SEC_PARAMS_t;

#define SIZEOF_OSD_CDB_SEC_PARAMS_t 200 
static inline void GENERIC_ENCAP_CDB_SEC_PARAMS(
    OSD_CDB_SEC_PARAMS_t *dst,
    const uint8_desc_t src_capability[80], 
    const uint8_desc_t src_req_int_chk_val[20], 
    array12_desc_t src_req_nonce, 
    offset32_desc_t src_din_int_chk_ofs, 
    offset32_desc_t src_dout_int_chk_ofs )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CDB_SEC_PARAMS_t));
    //memset((void*)(&(dst->reserved0)),0,80);
    { int ii; for (ii=0;ii<80;ii++) {
        UINT8_ENCAP((dst->capability)[ii], src_capability[ii]);
    }}
    { int ii; for (ii=0;ii<20;ii++) {
        UINT8_ENCAP((dst->req_int_chk_val)[ii], src_req_int_chk_val[ii]);
    }}
    ARRAY12_ENCAP((dst->req_nonce), src_req_nonce);
    OFFSET32_ENCAP((dst->din_int_chk_ofs), src_din_int_chk_ofs);
    OFFSET32_ENCAP((dst->dout_int_chk_ofs), src_dout_int_chk_ofs);
}

static inline void GENERIC_DECAP_CDB_SEC_PARAMS(
    const OSD_CDB_SEC_PARAMS_t *src,
    uint8_desc_t dst_capability[80], 
    uint8_desc_t dst_req_int_chk_val[20], 
    array12_desc_t *dst_req_nonce, 
    offset32_desc_t *dst_din_int_chk_ofs, 
    offset32_desc_t *dst_dout_int_chk_ofs)
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CDB_SEC_PARAMS_t));
    osd_assert(dst_capability);
    { int ii; for (ii=0;ii<80;ii++) {
        UINT8_DECAP((src->capability)[ii], (dst_capability[ii]));
    }}
    osd_assert(dst_req_int_chk_val);
    { int ii; for (ii=0;ii<20;ii++) {
        UINT8_DECAP((src->req_int_chk_val)[ii], (dst_req_int_chk_val[ii]));
    }}
    osd_assert(dst_req_nonce);
    ARRAY12_DECAP((src->req_nonce), (*dst_req_nonce));
    osd_assert(dst_din_int_chk_ofs);
    OFFSET32_DECAP((src->din_int_chk_ofs), (*dst_din_int_chk_ofs));
    osd_assert(dst_dout_int_chk_ofs);
    OFFSET32_DECAP((src->dout_int_chk_ofs), (*dst_dout_int_chk_ofs));
}

static inline void GENERIC_PRINT_CDB_SEC_PARAMS( const OSD_CDB_SEC_PARAMS_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    { int ii; for (ii=0;ii<80;ii++) {
      if ( (ii>2) && (ii<78)) ii=78;
        UINT8_PRINT(80+(ii*1), "capability[]", (src->capability[ii]));
    } }
    { int ii; for (ii=0;ii<20;ii++) {
      if ( (ii>2) && (ii<18)) ii=18;
        UINT8_PRINT(160+(ii*1), "req_int_chk_val[]", (src->req_int_chk_val[ii]));
    } }
    ARRAY12_PRINT(180, "req_nonce", (src->req_nonce));
CHECK_OFS(src, &(src->req_nonce),180);    OFFSET32_PRINT(192, "din_int_chk_ofs", (src->din_int_chk_ofs));
CHECK_OFS(src, &(src->din_int_chk_ofs),192);    OFFSET32_PRINT(196, "dout_int_chk_ofs", (src->dout_int_chk_ofs));
CHECK_OFS(src, &(src->dout_int_chk_ofs),196);}



#define OSD_STRUCT_CDB_CMD_READWRITE (&(gen_structs[4]))

#define OSD_FIELD_CDB_CMD_READWRITE_reserved0 (&(gen_structs[4].fields[0])) 
#define OSD_FIELD_CDB_CMD_READWRITE_reserved1 (&(gen_structs[4].fields[1])) 
#define OSD_FIELD_CDB_CMD_READWRITE_partition_id (&(gen_structs[4].fields[2])) 
#define OSD_FIELD_CDB_CMD_READWRITE_obj_id (&(gen_structs[4].fields[3])) 
#define OSD_FIELD_CDB_CMD_READWRITE_reserved2 (&(gen_structs[4].fields[4])) 
#define OSD_FIELD_CDB_CMD_READWRITE_length (&(gen_structs[4].fields[5])) 
#define OSD_FIELD_CDB_CMD_READWRITE_starting_byte_ofs (&(gen_structs[4].fields[6])) 

typedef struct {
    uint8_t reserved0[13];
    uint8_t reserved1[3];
    uint64_t partition_id;
    uint64_t obj_id;
    uint8_t reserved2[4];
    uint64_t length;
    uint64_t starting_byte_ofs;
    PACKED_STRUCT_END;
} PACKED OSD_CDB_CMD_READWRITE_t;

#define SIZEOF_OSD_CDB_CMD_READWRITE_t 52 
static inline void GENERIC_ENCAP_CDB_CMD_READWRITE(
    OSD_CDB_CMD_READWRITE_t *dst,
    uint64_desc_t src_partition_id, 
    uint64_desc_t src_obj_id, 
    uint64_desc_t src_length, 
    uint64_desc_t src_starting_byte_ofs )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CDB_CMD_READWRITE_t));
    //memset((void*)(&(dst->reserved0)),0,13);
    //memset((void*)(&(dst->reserved1)),0,3);
    osd_valid_id(src_partition_id,"CDB_CMD_READWRITE","partition_id");
    UINT64_ENCAP((dst->partition_id), src_partition_id);
    osd_valid_id(src_obj_id,"CDB_CMD_READWRITE","obj_id");
    UINT64_ENCAP((dst->obj_id), src_obj_id);
    //memset((void*)(&(dst->reserved2)),0,4);
    UINT64_ENCAP((dst->length), src_length);
    UINT64_ENCAP((dst->starting_byte_ofs), src_starting_byte_ofs);
}

static inline void GENERIC_DECAP_CDB_CMD_READWRITE(
    const OSD_CDB_CMD_READWRITE_t *src,
    uint64_desc_t *dst_partition_id, 
    uint64_desc_t *dst_obj_id, 
    uint64_desc_t *dst_length, 
    uint64_desc_t *dst_starting_byte_ofs)
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CDB_CMD_READWRITE_t));
    osd_assert(dst_partition_id);
    UINT64_DECAP((src->partition_id), (*dst_partition_id));
    osd_valid_id(*dst_partition_id,"CDB_CMD_READWRITE","partition_id");
    osd_assert(dst_obj_id);
    UINT64_DECAP((src->obj_id), (*dst_obj_id));
    osd_valid_id(*dst_obj_id,"CDB_CMD_READWRITE","obj_id");
    osd_assert(dst_length);
    UINT64_DECAP((src->length), (*dst_length));
    osd_assert(dst_starting_byte_ofs);
    UINT64_DECAP((src->starting_byte_ofs), (*dst_starting_byte_ofs));
}

static inline void GENERIC_PRINT_CDB_CMD_READWRITE( const OSD_CDB_CMD_READWRITE_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    UINT64_PRINT(16, "partition_id", (src->partition_id));
CHECK_OFS(src, &(src->partition_id),16);    UINT64_PRINT(24, "obj_id", (src->obj_id));
CHECK_OFS(src, &(src->obj_id),24);    UINT64_PRINT(36, "length", (src->length));
CHECK_OFS(src, &(src->length),36);    UINT64_PRINT(44, "starting_byte_ofs", (src->starting_byte_ofs));
CHECK_OFS(src, &(src->starting_byte_ofs),44);}



#define OSD_STRUCT_CDB_CMD_APPEND (&(gen_structs[5]))

#define OSD_FIELD_CDB_CMD_APPEND_reserved0 (&(gen_structs[5].fields[0])) 
#define OSD_FIELD_CDB_CMD_APPEND_reserved1 (&(gen_structs[5].fields[1])) 
#define OSD_FIELD_CDB_CMD_APPEND_partition_id (&(gen_structs[5].fields[2])) 
#define OSD_FIELD_CDB_CMD_APPEND_obj_id (&(gen_structs[5].fields[3])) 
#define OSD_FIELD_CDB_CMD_APPEND_reserved2 (&(gen_structs[5].fields[4])) 
#define OSD_FIELD_CDB_CMD_APPEND_length (&(gen_structs[5].fields[5])) 
#define OSD_FIELD_CDB_CMD_APPEND_reserved3 (&(gen_structs[5].fields[6])) 

typedef struct {
    uint8_t reserved0[13];
    uint8_t reserved1[3];
    uint64_t partition_id;
    uint64_t obj_id;
    uint8_t reserved2[4];
    uint64_t length;
    uint8_t reserved3[8];
    PACKED_STRUCT_END;
} PACKED OSD_CDB_CMD_APPEND_t;

#define SIZEOF_OSD_CDB_CMD_APPEND_t 52 
static inline void GENERIC_ENCAP_CDB_CMD_APPEND(
    OSD_CDB_CMD_APPEND_t *dst,
    uint64_desc_t src_partition_id, 
    uint64_desc_t src_obj_id, 
    uint64_desc_t src_length )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CDB_CMD_APPEND_t));
    //memset((void*)(&(dst->reserved0)),0,13);
    //memset((void*)(&(dst->reserved1)),0,3);
    osd_valid_id(src_partition_id,"CDB_CMD_APPEND","partition_id");
    UINT64_ENCAP((dst->partition_id), src_partition_id);
    osd_valid_id(src_obj_id,"CDB_CMD_APPEND","obj_id");
    UINT64_ENCAP((dst->obj_id), src_obj_id);
    //memset((void*)(&(dst->reserved2)),0,4);
    UINT64_ENCAP((dst->length), src_length);
    //memset((void*)(&(dst->reserved3)),0,8);
}

static inline void GENERIC_DECAP_CDB_CMD_APPEND(
    const OSD_CDB_CMD_APPEND_t *src,
    uint64_desc_t *dst_partition_id, 
    uint64_desc_t *dst_obj_id, 
    uint64_desc_t *dst_length)
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CDB_CMD_APPEND_t));
    osd_assert(dst_partition_id);
    UINT64_DECAP((src->partition_id), (*dst_partition_id));
    osd_valid_id(*dst_partition_id,"CDB_CMD_APPEND","partition_id");
    osd_assert(dst_obj_id);
    UINT64_DECAP((src->obj_id), (*dst_obj_id));
    osd_valid_id(*dst_obj_id,"CDB_CMD_APPEND","obj_id");
    osd_assert(dst_length);
    UINT64_DECAP((src->length), (*dst_length));
}

static inline void GENERIC_PRINT_CDB_CMD_APPEND( const OSD_CDB_CMD_APPEND_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    UINT64_PRINT(16, "partition_id", (src->partition_id));
CHECK_OFS(src, &(src->partition_id),16);    UINT64_PRINT(24, "obj_id", (src->obj_id));
CHECK_OFS(src, &(src->obj_id),24);    UINT64_PRINT(36, "length", (src->length));
CHECK_OFS(src, &(src->length),36);}



#define OSD_STRUCT_CDB_CMD_CREATE (&(gen_structs[6]))

#define OSD_FIELD_CDB_CMD_CREATE_reserved0 (&(gen_structs[6].fields[0])) 
#define OSD_FIELD_CDB_CMD_CREATE_reserved1 (&(gen_structs[6].fields[1])) 
#define OSD_FIELD_CDB_CMD_CREATE_partition_id (&(gen_structs[6].fields[2])) 
#define OSD_FIELD_CDB_CMD_CREATE_requested_obj_id (&(gen_structs[6].fields[3])) 
#define OSD_FIELD_CDB_CMD_CREATE_reserved2 (&(gen_structs[6].fields[4])) 
#define OSD_FIELD_CDB_CMD_CREATE_num_of_objects (&(gen_structs[6].fields[5])) 
#define OSD_FIELD_CDB_CMD_CREATE_reserved3 (&(gen_structs[6].fields[6])) 

typedef struct {
    uint8_t reserved0[13];
    uint8_t reserved1[3];
    uint64_t partition_id;
    uint64_t requested_obj_id;
    uint8_t reserved2[4];
    uint16_t num_of_objects;
    uint8_t reserved3[14];
    PACKED_STRUCT_END;
} PACKED OSD_CDB_CMD_CREATE_t;

#define SIZEOF_OSD_CDB_CMD_CREATE_t 52 
static inline void GENERIC_ENCAP_CDB_CMD_CREATE(
    OSD_CDB_CMD_CREATE_t *dst,
    uint64_desc_t src_partition_id, 
    uint64_desc_t src_requested_obj_id, 
    uint16_desc_t src_num_of_objects )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CDB_CMD_CREATE_t));
    //memset((void*)(&(dst->reserved0)),0,13);
    //memset((void*)(&(dst->reserved1)),0,3);
    osd_valid_id(src_partition_id,"CDB_CMD_CREATE","partition_id");
    UINT64_ENCAP((dst->partition_id), src_partition_id);
    osd_valid_or_zero_id(src_requested_obj_id,"CDB_CMD_CREATE","requested_obj_id");
    UINT64_ENCAP((dst->requested_obj_id), src_requested_obj_id);
    //memset((void*)(&(dst->reserved2)),0,4);
    UINT16_ENCAP((dst->num_of_objects), src_num_of_objects);
    //memset((void*)(&(dst->reserved3)),0,14);
}

static inline void GENERIC_DECAP_CDB_CMD_CREATE(
    const OSD_CDB_CMD_CREATE_t *src,
    uint64_desc_t *dst_partition_id, 
    uint64_desc_t *dst_requested_obj_id, 
    uint16_desc_t *dst_num_of_objects)
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CDB_CMD_CREATE_t));
    osd_assert(dst_partition_id);
    UINT64_DECAP((src->partition_id), (*dst_partition_id));
    osd_valid_id(*dst_partition_id,"CDB_CMD_CREATE","partition_id");
    osd_assert(dst_requested_obj_id);
    UINT64_DECAP((src->requested_obj_id), (*dst_requested_obj_id));
    osd_valid_or_zero_id(*dst_requested_obj_id,"CDB_CMD_CREATE","requested_obj_id");
    osd_assert(dst_num_of_objects);
    UINT16_DECAP((src->num_of_objects), (*dst_num_of_objects));
}

static inline void GENERIC_PRINT_CDB_CMD_CREATE( const OSD_CDB_CMD_CREATE_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    UINT64_PRINT(16, "partition_id", (src->partition_id));
CHECK_OFS(src, &(src->partition_id),16);    UINT64_PRINT(24, "requested_obj_id", (src->requested_obj_id));
CHECK_OFS(src, &(src->requested_obj_id),24);    UINT16_PRINT(36, "num_of_objects", (src->num_of_objects));
CHECK_OFS(src, &(src->num_of_objects),36);}



#define OSD_STRUCT_CDB_CMD_CREATE_AND_WRITE (&(gen_structs[7]))

#define OSD_FIELD_CDB_CMD_CREATE_AND_WRITE_reserved0 (&(gen_structs[7].fields[0])) 
#define OSD_FIELD_CDB_CMD_CREATE_AND_WRITE_reserved1 (&(gen_structs[7].fields[1])) 
#define OSD_FIELD_CDB_CMD_CREATE_AND_WRITE_partition_id (&(gen_structs[7].fields[2])) 
#define OSD_FIELD_CDB_CMD_CREATE_AND_WRITE_req_obj_id (&(gen_structs[7].fields[3])) 
#define OSD_FIELD_CDB_CMD_CREATE_AND_WRITE_reserved2 (&(gen_structs[7].fields[4])) 
#define OSD_FIELD_CDB_CMD_CREATE_AND_WRITE_length (&(gen_structs[7].fields[5])) 
#define OSD_FIELD_CDB_CMD_CREATE_AND_WRITE_starting_byte_ofs (&(gen_structs[7].fields[6])) 

typedef struct {
    uint8_t reserved0[13];
    uint8_t reserved1[3];
    uint64_t partition_id;
    uint64_t req_obj_id;
    uint8_t reserved2[4];
    uint64_t length;
    uint64_t starting_byte_ofs;
    PACKED_STRUCT_END;
} PACKED OSD_CDB_CMD_CREATE_AND_WRITE_t;

#define SIZEOF_OSD_CDB_CMD_CREATE_AND_WRITE_t 52 
static inline void GENERIC_ENCAP_CDB_CMD_CREATE_AND_WRITE(
    OSD_CDB_CMD_CREATE_AND_WRITE_t *dst,
    uint64_desc_t src_partition_id, 
    uint64_desc_t src_req_obj_id, 
    uint64_desc_t src_length, 
    uint64_desc_t src_starting_byte_ofs )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CDB_CMD_CREATE_AND_WRITE_t));
    //memset((void*)(&(dst->reserved0)),0,13);
    //memset((void*)(&(dst->reserved1)),0,3);
    osd_valid_id(src_partition_id,"CDB_CMD_CREATE_AND_WRITE","partition_id");
    UINT64_ENCAP((dst->partition_id), src_partition_id);
    osd_valid_or_zero_id(src_req_obj_id,"CDB_CMD_CREATE_AND_WRITE","req_obj_id");
    UINT64_ENCAP((dst->req_obj_id), src_req_obj_id);
    //memset((void*)(&(dst->reserved2)),0,4);
    UINT64_ENCAP((dst->length), src_length);
    UINT64_ENCAP((dst->starting_byte_ofs), src_starting_byte_ofs);
}

static inline void GENERIC_DECAP_CDB_CMD_CREATE_AND_WRITE(
    const OSD_CDB_CMD_CREATE_AND_WRITE_t *src,
    uint64_desc_t *dst_partition_id, 
    uint64_desc_t *dst_req_obj_id, 
    uint64_desc_t *dst_length, 
    uint64_desc_t *dst_starting_byte_ofs)
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CDB_CMD_CREATE_AND_WRITE_t));
    osd_assert(dst_partition_id);
    UINT64_DECAP((src->partition_id), (*dst_partition_id));
    osd_valid_id(*dst_partition_id,"CDB_CMD_CREATE_AND_WRITE","partition_id");
    osd_assert(dst_req_obj_id);
    UINT64_DECAP((src->req_obj_id), (*dst_req_obj_id));
    osd_valid_or_zero_id(*dst_req_obj_id,"CDB_CMD_CREATE_AND_WRITE","req_obj_id");
    osd_assert(dst_length);
    UINT64_DECAP((src->length), (*dst_length));
    osd_assert(dst_starting_byte_ofs);
    UINT64_DECAP((src->starting_byte_ofs), (*dst_starting_byte_ofs));
}

static inline void GENERIC_PRINT_CDB_CMD_CREATE_AND_WRITE( const OSD_CDB_CMD_CREATE_AND_WRITE_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    UINT64_PRINT(16, "partition_id", (src->partition_id));
CHECK_OFS(src, &(src->partition_id),16);    UINT64_PRINT(24, "req_obj_id", (src->req_obj_id));
CHECK_OFS(src, &(src->req_obj_id),24);    UINT64_PRINT(36, "length", (src->length));
CHECK_OFS(src, &(src->length),36);    UINT64_PRINT(44, "starting_byte_ofs", (src->starting_byte_ofs));
CHECK_OFS(src, &(src->starting_byte_ofs),44);}



#define OSD_STRUCT_CDB_CMD_ON_SOMETHING (&(gen_structs[8]))
//format of cdb for attr-get/attr-set commands

#define OSD_FIELD_CDB_CMD_ON_SOMETHING_reserved0 (&(gen_structs[8].fields[0])) 
#define OSD_FIELD_CDB_CMD_ON_SOMETHING_reserved1 (&(gen_structs[8].fields[1])) 
#define OSD_FIELD_CDB_CMD_ON_SOMETHING_partition_id (&(gen_structs[8].fields[2])) 
#define OSD_FIELD_CDB_CMD_ON_SOMETHING_obj_id (&(gen_structs[8].fields[3])) 
#define OSD_FIELD_CDB_CMD_ON_SOMETHING_reserved2 (&(gen_structs[8].fields[4])) 

typedef struct {
    uint8_t reserved0[13];
    uint8_t reserved1[3];
    uint64_t partition_id;
    uint64_t obj_id;
    uint8_t reserved2[20];
    PACKED_STRUCT_END;
} PACKED OSD_CDB_CMD_ON_SOMETHING_t;

#define SIZEOF_OSD_CDB_CMD_ON_SOMETHING_t 52 
static inline void GENERIC_ENCAP_CDB_CMD_ON_SOMETHING(
    OSD_CDB_CMD_ON_SOMETHING_t *dst,
    uint64_desc_t src_partition_id, 
    uint64_desc_t src_obj_id )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CDB_CMD_ON_SOMETHING_t));
    //memset((void*)(&(dst->reserved0)),0,13);
    //memset((void*)(&(dst->reserved1)),0,3);
    osd_valid_or_zero_id(src_partition_id,"CDB_CMD_ON_SOMETHING","partition_id");
    UINT64_ENCAP((dst->partition_id), src_partition_id);
    osd_valid_or_zero_id(src_obj_id,"CDB_CMD_ON_SOMETHING","obj_id");
    UINT64_ENCAP((dst->obj_id), src_obj_id);
    //memset((void*)(&(dst->reserved2)),0,20);
}

static inline void GENERIC_DECAP_CDB_CMD_ON_SOMETHING(
    const OSD_CDB_CMD_ON_SOMETHING_t *src,
    uint64_desc_t *dst_partition_id, 
    uint64_desc_t *dst_obj_id)
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CDB_CMD_ON_SOMETHING_t));
    osd_assert(dst_partition_id);
    UINT64_DECAP((src->partition_id), (*dst_partition_id));
    osd_valid_or_zero_id(*dst_partition_id,"CDB_CMD_ON_SOMETHING","partition_id");
    osd_assert(dst_obj_id);
    UINT64_DECAP((src->obj_id), (*dst_obj_id));
    osd_valid_or_zero_id(*dst_obj_id,"CDB_CMD_ON_SOMETHING","obj_id");
}

static inline void GENERIC_PRINT_CDB_CMD_ON_SOMETHING( const OSD_CDB_CMD_ON_SOMETHING_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    UINT64_PRINT(16, "partition_id", (src->partition_id));
CHECK_OFS(src, &(src->partition_id),16);    UINT64_PRINT(24, "obj_id", (src->obj_id));
CHECK_OFS(src, &(src->obj_id),24);}



#define OSD_STRUCT_CDB_CMD_ON_OBJECT (&(gen_structs[9]))

#define OSD_FIELD_CDB_CMD_ON_OBJECT_reserved0 (&(gen_structs[9].fields[0])) 
#define OSD_FIELD_CDB_CMD_ON_OBJECT_reserved1 (&(gen_structs[9].fields[1])) 
#define OSD_FIELD_CDB_CMD_ON_OBJECT_partition_id (&(gen_structs[9].fields[2])) 
#define OSD_FIELD_CDB_CMD_ON_OBJECT_obj_id (&(gen_structs[9].fields[3])) 
#define OSD_FIELD_CDB_CMD_ON_OBJECT_reserved2 (&(gen_structs[9].fields[4])) 

typedef struct {
    uint8_t reserved0[13];
    uint8_t reserved1[3];
    uint64_t partition_id;
    uint64_t obj_id;
    uint8_t reserved2[20];
    PACKED_STRUCT_END;
} PACKED OSD_CDB_CMD_ON_OBJECT_t;

#define SIZEOF_OSD_CDB_CMD_ON_OBJECT_t 52 
static inline void GENERIC_ENCAP_CDB_CMD_ON_OBJECT(
    OSD_CDB_CMD_ON_OBJECT_t *dst,
    uint64_desc_t src_partition_id, 
    uint64_desc_t src_obj_id )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CDB_CMD_ON_OBJECT_t));
    //memset((void*)(&(dst->reserved0)),0,13);
    //memset((void*)(&(dst->reserved1)),0,3);
    osd_valid_id(src_partition_id,"CDB_CMD_ON_OBJECT","partition_id");
    UINT64_ENCAP((dst->partition_id), src_partition_id);
    osd_valid_id(src_obj_id,"CDB_CMD_ON_OBJECT","obj_id");
    UINT64_ENCAP((dst->obj_id), src_obj_id);
    //memset((void*)(&(dst->reserved2)),0,20);
}

static inline void GENERIC_DECAP_CDB_CMD_ON_OBJECT(
    const OSD_CDB_CMD_ON_OBJECT_t *src,
    uint64_desc_t *dst_partition_id, 
    uint64_desc_t *dst_obj_id)
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CDB_CMD_ON_OBJECT_t));
    osd_assert(dst_partition_id);
    UINT64_DECAP((src->partition_id), (*dst_partition_id));
    osd_valid_id(*dst_partition_id,"CDB_CMD_ON_OBJECT","partition_id");
    osd_assert(dst_obj_id);
    UINT64_DECAP((src->obj_id), (*dst_obj_id));
    osd_valid_id(*dst_obj_id,"CDB_CMD_ON_OBJECT","obj_id");
}

static inline void GENERIC_PRINT_CDB_CMD_ON_OBJECT( const OSD_CDB_CMD_ON_OBJECT_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    UINT64_PRINT(16, "partition_id", (src->partition_id));
CHECK_OFS(src, &(src->partition_id),16);    UINT64_PRINT(24, "obj_id", (src->obj_id));
CHECK_OFS(src, &(src->obj_id),24);}



#define OSD_STRUCT_CDB_CMD_CREATE_PARTITION (&(gen_structs[10]))

#define OSD_FIELD_CDB_CMD_CREATE_PARTITION_reserved0 (&(gen_structs[10].fields[0])) 
#define OSD_FIELD_CDB_CMD_CREATE_PARTITION_reserved1 (&(gen_structs[10].fields[1])) 
#define OSD_FIELD_CDB_CMD_CREATE_PARTITION_req_partition_id (&(gen_structs[10].fields[2])) 
#define OSD_FIELD_CDB_CMD_CREATE_PARTITION_reserved2 (&(gen_structs[10].fields[3])) 

typedef struct {
    uint8_t reserved0[13];
    uint8_t reserved1[3];
    uint64_t req_partition_id;
    uint8_t reserved2[28];
    PACKED_STRUCT_END;
} PACKED OSD_CDB_CMD_CREATE_PARTITION_t;

#define SIZEOF_OSD_CDB_CMD_CREATE_PARTITION_t 52 
static inline void GENERIC_ENCAP_CDB_CMD_CREATE_PARTITION(
    OSD_CDB_CMD_CREATE_PARTITION_t *dst,
    uint64_desc_t src_req_partition_id )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CDB_CMD_CREATE_PARTITION_t));
    //memset((void*)(&(dst->reserved0)),0,13);
    //memset((void*)(&(dst->reserved1)),0,3);
    osd_valid_or_zero_id(src_req_partition_id,"CDB_CMD_CREATE_PARTITION","req_partition_id");
    UINT64_ENCAP((dst->req_partition_id), src_req_partition_id);
    //memset((void*)(&(dst->reserved2)),0,28);
}

static inline void GENERIC_DECAP_CDB_CMD_CREATE_PARTITION(
    const OSD_CDB_CMD_CREATE_PARTITION_t *src,
    uint64_desc_t *dst_req_partition_id)
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CDB_CMD_CREATE_PARTITION_t));
    osd_assert(dst_req_partition_id);
    UINT64_DECAP((src->req_partition_id), (*dst_req_partition_id));
    osd_valid_or_zero_id(*dst_req_partition_id,"CDB_CMD_CREATE_PARTITION","req_partition_id");
}

static inline void GENERIC_PRINT_CDB_CMD_CREATE_PARTITION( const OSD_CDB_CMD_CREATE_PARTITION_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    UINT64_PRINT(16, "req_partition_id", (src->req_partition_id));
CHECK_OFS(src, &(src->req_partition_id),16);}



#define OSD_STRUCT_CDB_CMD_ON_PARTITION (&(gen_structs[11]))

#define OSD_FIELD_CDB_CMD_ON_PARTITION_reserved0 (&(gen_structs[11].fields[0])) 
#define OSD_FIELD_CDB_CMD_ON_PARTITION_reserved1 (&(gen_structs[11].fields[1])) 
#define OSD_FIELD_CDB_CMD_ON_PARTITION_partition_id (&(gen_structs[11].fields[2])) 
#define OSD_FIELD_CDB_CMD_ON_PARTITION_reserved2 (&(gen_structs[11].fields[3])) 

typedef struct {
    uint8_t reserved0[13];
    uint8_t reserved1[3];
    uint64_t partition_id;
    uint8_t reserved2[28];
    PACKED_STRUCT_END;
} PACKED OSD_CDB_CMD_ON_PARTITION_t;

#define SIZEOF_OSD_CDB_CMD_ON_PARTITION_t 52 
static inline void GENERIC_ENCAP_CDB_CMD_ON_PARTITION(
    OSD_CDB_CMD_ON_PARTITION_t *dst,
    uint64_desc_t src_partition_id )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CDB_CMD_ON_PARTITION_t));
    //memset((void*)(&(dst->reserved0)),0,13);
    //memset((void*)(&(dst->reserved1)),0,3);
    osd_valid_id(src_partition_id,"CDB_CMD_ON_PARTITION","partition_id");
    UINT64_ENCAP((dst->partition_id), src_partition_id);
    //memset((void*)(&(dst->reserved2)),0,28);
}

static inline void GENERIC_DECAP_CDB_CMD_ON_PARTITION(
    const OSD_CDB_CMD_ON_PARTITION_t *src,
    uint64_desc_t *dst_partition_id)
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CDB_CMD_ON_PARTITION_t));
    osd_assert(dst_partition_id);
    UINT64_DECAP((src->partition_id), (*dst_partition_id));
    osd_valid_id(*dst_partition_id,"CDB_CMD_ON_PARTITION","partition_id");
}

static inline void GENERIC_PRINT_CDB_CMD_ON_PARTITION( const OSD_CDB_CMD_ON_PARTITION_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    UINT64_PRINT(16, "partition_id", (src->partition_id));
CHECK_OFS(src, &(src->partition_id),16);}



#define OSD_STRUCT_CDB_CMD_FORMAT (&(gen_structs[12]))

#define OSD_FIELD_CDB_CMD_FORMAT_reserved0 (&(gen_structs[12].fields[0])) 
#define OSD_FIELD_CDB_CMD_FORMAT_reserved1 (&(gen_structs[12].fields[1])) 
#define OSD_FIELD_CDB_CMD_FORMAT_formatted_capacity (&(gen_structs[12].fields[2])) 
#define OSD_FIELD_CDB_CMD_FORMAT_reserved2 (&(gen_structs[12].fields[3])) 

typedef struct {
    uint8_t reserved0[13];
    uint8_t reserved1[23];
    uint64_t formatted_capacity;
    uint8_t reserved2[8];
    PACKED_STRUCT_END;
} PACKED OSD_CDB_CMD_FORMAT_t;

#define SIZEOF_OSD_CDB_CMD_FORMAT_t 52 
static inline void GENERIC_ENCAP_CDB_CMD_FORMAT(
    OSD_CDB_CMD_FORMAT_t *dst,
    uint64_desc_t src_formatted_capacity )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CDB_CMD_FORMAT_t));
    //memset((void*)(&(dst->reserved0)),0,13);
    //memset((void*)(&(dst->reserved1)),0,23);
    UINT64_ENCAP((dst->formatted_capacity), src_formatted_capacity);
    //memset((void*)(&(dst->reserved2)),0,8);
}

static inline void GENERIC_DECAP_CDB_CMD_FORMAT(
    const OSD_CDB_CMD_FORMAT_t *src,
    uint64_desc_t *dst_formatted_capacity)
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CDB_CMD_FORMAT_t));
    osd_assert(dst_formatted_capacity);
    UINT64_DECAP((src->formatted_capacity), (*dst_formatted_capacity));
}

static inline void GENERIC_PRINT_CDB_CMD_FORMAT( const OSD_CDB_CMD_FORMAT_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    UINT64_PRINT(36, "formatted_capacity", (src->formatted_capacity));
CHECK_OFS(src, &(src->formatted_capacity),36);}



#define OSD_STRUCT_CDB_CMD_LIST (&(gen_structs[13]))

#define OSD_FIELD_CDB_CMD_LIST_reserved0 (&(gen_structs[13].fields[0])) 
#define OSD_FIELD_CDB_CMD_LIST_reserved1 (&(gen_structs[13].fields[1])) 
#define OSD_FIELD_CDB_CMD_LIST_partition_id (&(gen_structs[13].fields[2])) 
#define OSD_FIELD_CDB_CMD_LIST_reserved2 (&(gen_structs[13].fields[3])) 
#define OSD_FIELD_CDB_CMD_LIST_list_identifier (&(gen_structs[13].fields[4])) 
#define OSD_FIELD_CDB_CMD_LIST_allocation_length (&(gen_structs[13].fields[5])) 
#define OSD_FIELD_CDB_CMD_LIST_initial_obj_id (&(gen_structs[13].fields[6])) 

typedef struct {
    uint8_t reserved0[13];
    uint8_t reserved1[3];
    uint64_t partition_id;
    uint8_t reserved2[8];
    uint32_t list_identifier;
    uint64_t allocation_length;
    uint64_t initial_obj_id;
    PACKED_STRUCT_END;
} PACKED OSD_CDB_CMD_LIST_t;

#define SIZEOF_OSD_CDB_CMD_LIST_t 52 
static inline void GENERIC_ENCAP_CDB_CMD_LIST(
    OSD_CDB_CMD_LIST_t *dst,
    uint64_desc_t src_partition_id, 
    uint32_desc_t src_list_identifier, 
    uint64_desc_t src_allocation_length, 
    uint64_desc_t src_initial_obj_id )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CDB_CMD_LIST_t));
    //memset((void*)(&(dst->reserved0)),0,13);
    //memset((void*)(&(dst->reserved1)),0,3);
    osd_valid_or_zero_id(src_partition_id,"CDB_CMD_LIST","partition_id");
    UINT64_ENCAP((dst->partition_id), src_partition_id);
    //memset((void*)(&(dst->reserved2)),0,8);
    UINT32_ENCAP((dst->list_identifier), src_list_identifier);
    UINT64_ENCAP((dst->allocation_length), src_allocation_length);
    UINT64_ENCAP((dst->initial_obj_id), src_initial_obj_id);
}

static inline void GENERIC_DECAP_CDB_CMD_LIST(
    const OSD_CDB_CMD_LIST_t *src,
    uint64_desc_t *dst_partition_id, 
    uint32_desc_t *dst_list_identifier, 
    uint64_desc_t *dst_allocation_length, 
    uint64_desc_t *dst_initial_obj_id)
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CDB_CMD_LIST_t));
    osd_assert(dst_partition_id);
    UINT64_DECAP((src->partition_id), (*dst_partition_id));
    osd_valid_or_zero_id(*dst_partition_id,"CDB_CMD_LIST","partition_id");
    osd_assert(dst_list_identifier);
    UINT32_DECAP((src->list_identifier), (*dst_list_identifier));
    osd_assert(dst_allocation_length);
    UINT64_DECAP((src->allocation_length), (*dst_allocation_length));
    osd_assert(dst_initial_obj_id);
    UINT64_DECAP((src->initial_obj_id), (*dst_initial_obj_id));
}

static inline void GENERIC_PRINT_CDB_CMD_LIST( const OSD_CDB_CMD_LIST_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    UINT64_PRINT(16, "partition_id", (src->partition_id));
CHECK_OFS(src, &(src->partition_id),16);    UINT32_PRINT(32, "list_identifier", (src->list_identifier));
CHECK_OFS(src, &(src->list_identifier),32);    UINT64_PRINT(36, "allocation_length", (src->allocation_length));
CHECK_OFS(src, &(src->allocation_length),36);    UINT64_PRINT(44, "initial_obj_id", (src->initial_obj_id));
CHECK_OFS(src, &(src->initial_obj_id),44);}



#define OSD_STRUCT_CDB_CMD_SET_KEY (&(gen_structs[14]))

#define OSD_FIELD_CDB_CMD_SET_KEY_reserved0 (&(gen_structs[14].fields[0])) 
#define OSD_FIELD_CDB_CMD_SET_KEY_reserved1 (&(gen_structs[14].fields[1])) 
#define OSD_FIELD_CDB_CMD_SET_KEY_partition_id (&(gen_structs[14].fields[2])) 
#define OSD_FIELD_CDB_CMD_SET_KEY_key_ver (&(gen_structs[14].fields[3])) 
#define OSD_FIELD_CDB_CMD_SET_KEY_key_id (&(gen_structs[14].fields[4])) 
#define OSD_FIELD_CDB_CMD_SET_KEY_seed (&(gen_structs[14].fields[5])) 

typedef struct {
    uint8_t reserved0[13];
    uint8_t reserved1[3];
    uint64_t partition_id;
    uint8_t key_ver;
    uint8_t key_id[7];
    uint8_t seed[20];
    PACKED_STRUCT_END;
} PACKED OSD_CDB_CMD_SET_KEY_t;

#define SIZEOF_OSD_CDB_CMD_SET_KEY_t 52 
static inline void GENERIC_ENCAP_CDB_CMD_SET_KEY(
    OSD_CDB_CMD_SET_KEY_t *dst,
    uint64_desc_t src_partition_id, 
    uint8_desc_t src_key_ver, 
    const uint8_desc_t src_key_id[7], 
    const uint8_desc_t src_seed[20] )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CDB_CMD_SET_KEY_t));
    //memset((void*)(&(dst->reserved0)),0,13);
    //memset((void*)(&(dst->reserved1)),0,3);
    osd_valid_or_zero_id(src_partition_id,"CDB_CMD_SET_KEY","partition_id");
    UINT64_ENCAP((dst->partition_id), src_partition_id);
    UINT8_ENCAP((dst->key_ver), src_key_ver);
    { int ii; for (ii=0;ii<7;ii++) {
        UINT8_ENCAP((dst->key_id)[ii], src_key_id[ii]);
    }}
    { int ii; for (ii=0;ii<20;ii++) {
        UINT8_ENCAP((dst->seed)[ii], src_seed[ii]);
    }}
}

static inline void GENERIC_DECAP_CDB_CMD_SET_KEY(
    const OSD_CDB_CMD_SET_KEY_t *src,
    uint64_desc_t *dst_partition_id, 
    uint8_desc_t *dst_key_ver, 
    uint8_desc_t dst_key_id[7], 
    uint8_desc_t dst_seed[20])
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CDB_CMD_SET_KEY_t));
    osd_assert(dst_partition_id);
    UINT64_DECAP((src->partition_id), (*dst_partition_id));
    osd_valid_or_zero_id(*dst_partition_id,"CDB_CMD_SET_KEY","partition_id");
    osd_assert(dst_key_ver);
    UINT8_DECAP((src->key_ver), (*dst_key_ver));
    osd_assert(dst_key_id);
    { int ii; for (ii=0;ii<7;ii++) {
        UINT8_DECAP((src->key_id)[ii], (dst_key_id[ii]));
    }}
    osd_assert(dst_seed);
    { int ii; for (ii=0;ii<20;ii++) {
        UINT8_DECAP((src->seed)[ii], (dst_seed[ii]));
    }}
}

static inline void GENERIC_PRINT_CDB_CMD_SET_KEY( const OSD_CDB_CMD_SET_KEY_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    UINT64_PRINT(16, "partition_id", (src->partition_id));
CHECK_OFS(src, &(src->partition_id),16);    UINT8_PRINT(24, "key_ver", (src->key_ver));
CHECK_OFS(src, &(src->key_ver),24);    { int ii; for (ii=0;ii<7;ii++) {
      if ( (ii>2) && (ii<5)) ii=5;
        UINT8_PRINT(25+(ii*1), "key_id[]", (src->key_id[ii]));
    } }
    { int ii; for (ii=0;ii<20;ii++) {
      if ( (ii>2) && (ii<18)) ii=18;
        UINT8_PRINT(32+(ii*1), "seed[]", (src->seed[ii]));
    } }
}



#define OSD_STRUCT_CAPABILITY (&(gen_structs[15]))

	//lower nibble codes capability format
#define OSD_FIELD_CAPABILITY_format (&(gen_structs[15].fields[0])) 
	//lower nibble codes integrity check value algorithm
	//upper nibble codes key version
#define OSD_FIELD_CAPABILITY_byte2 (&(gen_structs[15].fields[1])) 
	//lower nibble codes security method
	//upper nibble codes key version
#define OSD_FIELD_CAPABILITY_sec_method (&(gen_structs[15].fields[2])) 
#define OSD_FIELD_CAPABILITY_reserved1 (&(gen_structs[15].fields[3])) 
#define OSD_FIELD_CAPABILITY_expiration_time (&(gen_structs[15].fields[4])) 
#define OSD_FIELD_CAPABILITY_audit (&(gen_structs[15].fields[5])) 
#define OSD_FIELD_CAPABILITY_discriminator (&(gen_structs[15].fields[6])) 
#define OSD_FIELD_CAPABILITY_obj_creation_time (&(gen_structs[15].fields[7])) 
#define OSD_FIELD_CAPABILITY_obj_type (&(gen_structs[15].fields[8])) 
#define OSD_FIELD_CAPABILITY_permission_bits (&(gen_structs[15].fields[9])) 
#define OSD_FIELD_CAPABILITY_reserved2 (&(gen_structs[15].fields[10])) 
    //can be 1=User/Collection Obj or 2=Partition
#define OSD_FIELD_CAPABILITY_obj_desc_type (&(gen_structs[15].fields[11])) 
    //of the allowed object
#define OSD_FIELD_CAPABILITY_policy_access_tag (&(gen_structs[15].fields[12])) 
    //always used
#define OSD_FIELD_CAPABILITY_allowed_pid (&(gen_structs[15].fields[13])) 
    //unused for partition
#define OSD_FIELD_CAPABILITY_allowed_oid (&(gen_structs[15].fields[14])) 
#define OSD_FIELD_CAPABILITY_reserved3 (&(gen_structs[15].fields[15])) 

typedef struct {
    uint8_t format;
    uint8_t byte2;
    uint8_t sec_method;
    uint8_t reserved1;
    uint48_t expiration_time;
    uint8_t audit[20];
    array12_t discriminator;
    uint48_t obj_creation_time;
    uint8_t obj_type;
    uint16_t permission_bits;
    uint8_t reserved2[4];
    uint8_t obj_desc_type;
    uint32_t policy_access_tag;
    uint64_t allowed_pid;
    uint64_t allowed_oid;
    uint32_t reserved3;
    PACKED_STRUCT_END;
} PACKED OSD_CAPABILITY_t;

#define SIZEOF_OSD_CAPABILITY_t 80 
static inline void GENERIC_ENCAP_CAPABILITY(
    OSD_CAPABILITY_t *dst,
    uint8_desc_t src_format, 
    uint8_desc_t src_byte2, 
    uint8_desc_t src_sec_method, 
    uint48_desc_t src_expiration_time, 
    const uint8_desc_t src_audit[20], 
    array12_desc_t src_discriminator, 
    uint48_desc_t src_obj_creation_time, 
    uint8_desc_t src_obj_type, 
    uint16_desc_t src_permission_bits, 
    uint8_desc_t src_obj_desc_type, 
    uint32_desc_t src_policy_access_tag, 
    uint64_desc_t src_allowed_pid, 
    uint64_desc_t src_allowed_oid )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CAPABILITY_t));
    UINT8_ENCAP((dst->format), src_format);
    UINT8_ENCAP((dst->byte2), src_byte2);
    UINT8_ENCAP((dst->sec_method), src_sec_method);
    //memset((void*)(&(dst->reserved1)),0,1);
    UINT48_ENCAP((dst->expiration_time), src_expiration_time);
    { int ii; for (ii=0;ii<20;ii++) {
        UINT8_ENCAP((dst->audit)[ii], src_audit[ii]);
    }}
    ARRAY12_ENCAP((dst->discriminator), src_discriminator);
    UINT48_ENCAP((dst->obj_creation_time), src_obj_creation_time);
    UINT8_ENCAP((dst->obj_type), src_obj_type);
    UINT16_ENCAP((dst->permission_bits), src_permission_bits);
    //memset((void*)(&(dst->reserved2)),0,4);
    UINT8_ENCAP((dst->obj_desc_type), src_obj_desc_type);
    UINT32_ENCAP((dst->policy_access_tag), src_policy_access_tag);
    UINT64_ENCAP((dst->allowed_pid), src_allowed_pid);
    UINT64_ENCAP((dst->allowed_oid), src_allowed_oid);
    //memset((void*)(&(dst->reserved3)),0,4);
}

static inline void GENERIC_DECAP_CAPABILITY(
    const OSD_CAPABILITY_t *src,
    uint8_desc_t *dst_format, 
    uint8_desc_t *dst_byte2, 
    uint8_desc_t *dst_sec_method, 
    uint48_desc_t *dst_expiration_time, 
    uint8_desc_t dst_audit[20], 
    array12_desc_t *dst_discriminator, 
    uint48_desc_t *dst_obj_creation_time, 
    uint8_desc_t *dst_obj_type, 
    uint16_desc_t *dst_permission_bits, 
    uint8_desc_t *dst_obj_desc_type, 
    uint32_desc_t *dst_policy_access_tag, 
    uint64_desc_t *dst_allowed_pid, 
    uint64_desc_t *dst_allowed_oid)
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CAPABILITY_t));
    osd_assert(dst_format);
    UINT8_DECAP((src->format), (*dst_format));
    osd_assert(dst_byte2);
    UINT8_DECAP((src->byte2), (*dst_byte2));
    osd_assert(dst_sec_method);
    UINT8_DECAP((src->sec_method), (*dst_sec_method));
    osd_assert(dst_expiration_time);
    UINT48_DECAP((src->expiration_time), (*dst_expiration_time));
    osd_assert(dst_audit);
    { int ii; for (ii=0;ii<20;ii++) {
        UINT8_DECAP((src->audit)[ii], (dst_audit[ii]));
    }}
    osd_assert(dst_discriminator);
    ARRAY12_DECAP((src->discriminator), (*dst_discriminator));
    osd_assert(dst_obj_creation_time);
    UINT48_DECAP((src->obj_creation_time), (*dst_obj_creation_time));
    osd_assert(dst_obj_type);
    UINT8_DECAP((src->obj_type), (*dst_obj_type));
    osd_assert(dst_permission_bits);
    UINT16_DECAP((src->permission_bits), (*dst_permission_bits));
    osd_assert(dst_obj_desc_type);
    UINT8_DECAP((src->obj_desc_type), (*dst_obj_desc_type));
    osd_assert(dst_policy_access_tag);
    UINT32_DECAP((src->policy_access_tag), (*dst_policy_access_tag));
    osd_assert(dst_allowed_pid);
    UINT64_DECAP((src->allowed_pid), (*dst_allowed_pid));
    osd_assert(dst_allowed_oid);
    UINT64_DECAP((src->allowed_oid), (*dst_allowed_oid));
}

static inline void GENERIC_PRINT_CAPABILITY( const OSD_CAPABILITY_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    UINT8_PRINT(0, "format", (src->format));
CHECK_OFS(src, &(src->format),0);    UINT8_PRINT(1, "byte2", (src->byte2));
CHECK_OFS(src, &(src->byte2),1);    UINT8_PRINT(2, "sec_method", (src->sec_method));
CHECK_OFS(src, &(src->sec_method),2);    UINT48_PRINT(4, "expiration_time", (src->expiration_time));
CHECK_OFS(src, &(src->expiration_time),4);    { int ii; for (ii=0;ii<20;ii++) {
      if ( (ii>2) && (ii<18)) ii=18;
        UINT8_PRINT(10+(ii*1), "audit[]", (src->audit[ii]));
    } }
    ARRAY12_PRINT(30, "discriminator", (src->discriminator));
CHECK_OFS(src, &(src->discriminator),30);    UINT48_PRINT(42, "obj_creation_time", (src->obj_creation_time));
CHECK_OFS(src, &(src->obj_creation_time),42);    UINT8_PRINT(48, "obj_type", (src->obj_type));
CHECK_OFS(src, &(src->obj_type),48);    UINT16_PRINT(49, "permission_bits", (src->permission_bits));
CHECK_OFS(src, &(src->permission_bits),49);    UINT8_PRINT(55, "obj_desc_type", (src->obj_desc_type));
CHECK_OFS(src, &(src->obj_desc_type),55);    UINT32_PRINT(56, "policy_access_tag", (src->policy_access_tag));
CHECK_OFS(src, &(src->policy_access_tag),56);    UINT64_PRINT(60, "allowed_pid", (src->allowed_pid));
CHECK_OFS(src, &(src->allowed_pid),60);    UINT64_PRINT(68, "allowed_oid", (src->allowed_oid));
CHECK_OFS(src, &(src->allowed_oid),68);}


// end of cdb formats
/////////////////////////////////////////

#define OSD_STRUCT_CMD_LIST_DATA_HDR (&(gen_structs[16]))
    //additional length is N*8+16 where N is the total number of
    //entries that would have been returned by this LIST command if
    //allocation length was infinite.

#define OSD_FIELD_CMD_LIST_DATA_HDR_additional_length (&(gen_structs[16].fields[0])) 
#define OSD_FIELD_CMD_LIST_DATA_HDR_continuation_obj_id (&(gen_structs[16].fields[1])) 
#define OSD_FIELD_CMD_LIST_DATA_HDR_list_identifier (&(gen_structs[16].fields[2])) 
#define OSD_FIELD_CMD_LIST_DATA_HDR_reserved1 (&(gen_structs[16].fields[3])) 
#define OSD_FIELD_CMD_LIST_DATA_HDR_flags (&(gen_structs[16].fields[4])) 

typedef struct {
    uint64_t additional_length;
    uint64_t continuation_obj_id;
    uint32_t list_identifier;
    uint8_t reserved1[3];
    uint8_t flags;
    PACKED_STRUCT_END;
} PACKED OSD_CMD_LIST_DATA_HDR_t;

#define SIZEOF_OSD_CMD_LIST_DATA_HDR_t 24 
static inline void GENERIC_ENCAP_CMD_LIST_DATA_HDR(
    OSD_CMD_LIST_DATA_HDR_t *dst,
    uint64_desc_t src_additional_length, 
    uint64_desc_t src_continuation_obj_id, 
    uint32_desc_t src_list_identifier, 
    uint8_desc_t src_flags )
{
    osd_assert(dst);
osd_assert(std_sizeof(OSD_CMD_LIST_DATA_HDR_t));
    UINT64_ENCAP((dst->additional_length), src_additional_length);
    UINT64_ENCAP((dst->continuation_obj_id), src_continuation_obj_id);
    UINT32_ENCAP((dst->list_identifier), src_list_identifier);
    //memset((void*)(&(dst->reserved1)),0,3);
    UINT8_ENCAP((dst->flags), src_flags);
}

static inline void GENERIC_DECAP_CMD_LIST_DATA_HDR(
    const OSD_CMD_LIST_DATA_HDR_t *src,
    uint64_desc_t *dst_additional_length, 
    uint64_desc_t *dst_continuation_obj_id, 
    uint32_desc_t *dst_list_identifier, 
    uint8_desc_t *dst_flags)
{
    osd_assert(src);
osd_assert(std_sizeof(OSD_CMD_LIST_DATA_HDR_t));
    osd_assert(dst_additional_length);
    UINT64_DECAP((src->additional_length), (*dst_additional_length));
    osd_assert(dst_continuation_obj_id);
    UINT64_DECAP((src->continuation_obj_id), (*dst_continuation_obj_id));
    osd_assert(dst_list_identifier);
    UINT32_DECAP((src->list_identifier), (*dst_list_identifier));
    osd_assert(dst_flags);
    UINT8_DECAP((src->flags), (*dst_flags));
}

static inline void GENERIC_PRINT_CMD_LIST_DATA_HDR( const OSD_CMD_LIST_DATA_HDR_t *src) {
    osd_assert(src);
    GEN_HDR_PRINT;
    UINT64_PRINT(0, "additional_length", (src->additional_length));
CHECK_OFS(src, &(src->additional_length),0);    UINT64_PRINT(8, "continuation_obj_id", (src->continuation_obj_id));
CHECK_OFS(src, &(src->continuation_obj_id),8);    UINT32_PRINT(16, "list_identifier", (src->list_identifier));
CHECK_OFS(src, &(src->list_identifier),16);    UINT8_PRINT(23, "flags", (src->flags));
CHECK_OFS(src, &(src->flags),23);}



#endif /*#ifndef OSD_CDB_FORMATS_H*/

