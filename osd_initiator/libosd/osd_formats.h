/*************************************************************
** Copyright 2004, 2005. IBM Corp.** All Rights Reserved.***
**************************************************************
** Redistribution and use in source and binary forms, with or without
** modifications, are permitted provided that the following conditions 
** are met:
** 
** i.  Redistribution of source code must retain the above copyright
**     notice, this list of conditions and the following disclaimer.
**
** ii. Redistribution in binary form must reproduce the above copyright 
**     notice, this list of conditions and the following disclaimer in the 
**     documentation and/or other materials provided with the distribution.
**
** iii.Neither the name(s) of IBM Corp.** nor the names of its/their
**     contributors may be used to endorse or promote products derived
**     from this software without specific prior written permission.
*******************************************************************
** THIS SOFTWARE IS PROVIDED BY IBM CORP. AND CONTRIBUTORS "AS IS" 
** AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING , BUT NOT LIMITED
** TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
** PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE IBM
** CORP. OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
** (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
** STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
** ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
** OF THE POSSIBILITY OF SUCH DAMAGE.
** 
*****************************************************************************
*****************************************************************************/

//file: osd_formats.h

#ifndef OSD_FORMATS_H
#define OSD_FORMATS_H

#include "osd.h"
#include "osd_util.h"
#include "osd_trace.h"

/* IMPORTANT NOTE: 
 * this file includes manually written parts directly related to 
 * automatic code generated by gen_formats.awk.
 * do not change this parts in this file w/o checking these relations
 */

static inline int int_osd_assert(int x, const char * desc) {
    if (!x) OSD_ERROR("assert on %s\n",desc);
    osd_assert(x);
    return x;
}

#define std_sizeof(type) \
((sizeof(type)==SIZEOF_##type)?sizeof(type):int_osd_assert(0,"SIZEOF_"#type))

#define PACKED OSD_PACKED
#define PACKED_STRUCT_END OSD_PACKED_STRUCT_END

//(SIZEOF_##type)

typedef osd_rc_t RC_t;

//defines used by auto-code
typedef enum {
    uint8_en,uint16_en,uint32_en,uint64_en,
    uint48_en,num_types
} type_num_t;

#define NUM_EMPTY 0xFFFFFFFF

//constants used by paeg number definitions in source for generated code
#define PAGE_CLS_MSK ((uint32_t)0xF0000000)
#define PAGE_P ((uint32_t)0x30000000)
#define PAGE_C ((uint32_t)0x60000000)
#define PAGE_R ((uint32_t)0x90000000)
#define PAGE_A ((uint32_t)0xF0000000)
#define PAGE_U ((uint32_t)0)

#define PAGE_T_STD ((uint32_t)0)
#define PAGE_T_USR ((uint32_t)0x10000000)
#define PAGE_T_VND ((uint32_t)0x20000000)

#define UINT8_ENCAP(dst,src) ((dst)=(src))
#define UINT8_DECAP(src,dst) ((dst)=(src))
#define UINT16_ENCAP(dst,src) ((dst)=HTONS(src))
#define UINT16_DECAP(src,dst) ((dst)=NTOHS(src))
#define UINT32_ENCAP(dst,src) ((dst)=HTONL(src))
#define UINT32_DECAP(src,dst) ((dst)=NTOHL(src))
#define UINT64_ENCAP(dst,src) ((dst)=HTONLL(src))
#define UINT64_DECAP(src,dst) ((dst)=NTOHLL(src))
#define OFFSET32_ENCAP(dst,src) ((dst)=gen_HTON_offset(src))
#define OFFSET32_DECAP(src,dst) ((dst)=gen_NTOH_offset(src))
#define ARRAY12_ENCAP(dst,src) \
do { osd_assert(sizeof(dst)==SIZEOF_array12_t);\
     memcpy((dst).b,(src).b,12); } while (0)
#define ARRAY12_DECAP(src,dst) \
do { osd_assert(sizeof(src)==SIZEOF_array12_t); \
     memcpy((dst).b,(src).b,12); } while (0)

#define UINT48_ENCAP(dst,src) \
do { osd_assert((src)<((uint64_t)1<<48)); \
     osd_assert(sizeof(dst)==SIZEOF_uint48_t); \
     (dst).millisecs = HTONS(src&0xFFFF); \
    (dst).minutes=HTONL((src>>16)&0xFFFFFFFF); } while (0)

#define UINT48_DECAP(src,dst) \
do { (dst)=NTOHL((src).minutes); dst<<=16; dst+=NTOHS((src).millisecs); \
     osd_assert(sizeof(src)==SIZEOF_uint48_t); \
} while(0)


#define GEN_HDR_PRINT PRINT("** OFS *** VAL ******************* NAME ******\n")

#define UINT8_PRINT(ofs,name,val) \
  PRINT("* %3d\t*               0x%02x\t* %s\n",ofs,val,name)

#define UINT16_PRINT(ofs,name,val) \
  PRINT("* %3d\t*             0x%04x\t* %s\n",ofs,NTOHS(val),name)

#define UINT32_PRINT(ofs,name,val) \
  PRINT("* %3d\t*         0x%08x\t* %s\n",ofs,NTOHL(val),name)

#define UINT64_PRINT(ofs,name,val) do \
{uint64_t v=NTOHLL(val); PRINT("* %3d\t* 0x%016llx\t* %s\n",ofs,v,name); } while(0)

#define OFFSET32_PRINT(ofs,name,val)                           \
do {uint64_t v=gen_NTOH_offset(val);                           \
 PRINT("* %3d\t* 0x%016llx\t* %s",ofs,v,name);                 \
 PRINT("%s\n",((v==OFFSET_IGNORE)?"(IGNORE OFS VALUE)":""));} while(0)

#define UINT48_PRINT(ofs,name,val) \
do { uint64_t v; UINT48_DECAP((val),v); \
     PRINT("* %3d\t*     0x%012llx\t* %s\n",ofs,v,name); } while(0);

#define ARRAY12_PRINT(ofs,name,val) \
UINT64_PRINT(ofs,name,*((uint64_t*)val.b))

static inline void CHECK_OFS(const void *base, const void*field, int ofs) {
    const uint8_t *b=(uint8_t *)base;
    const uint8_t *p=(uint8_t *)field;
    uint32_t o=(uint32_t)(p-b);
    if (o!=(uint32_t)ofs) {
	OSD_ERROR("struct ofs %d != std ofs %d\n",o,ofs);
	osd_assert(0);
    }
}
 
// access types for attributes. derived from "Can be set","OSD Provided"
// columns in standard
typedef enum { 
    OSD_ATTR_NO_ACCESS,//cannot be set, not usd provided
    OSD_ATTR_OSD_RD,   // cannot be set, osd provided
    OSD_ATTR_OSD_RW,   // can be set, osd provided
    OSD_ATTR_USER_RW,  // can be set, not osd provided
} attr_access_t;

static uint64_t gen_NTOH_offset(offset32_t cdb_offset);
static offset32_t gen_HTON_offset(uint64_t offset_val);

static void osd_valid_id(uint64_t partition_id,
					  const char* sname,const char*fname);
static void osd_valid_or_zero_id(uint64_t obj_id,
					const char* sname,const char*fname);

static void osd_valid_sec_method(uint8_t sec_method,
					const char* sname,const char*fname);

/*********************************************************
 * up to here were parts before auto-code include
 * (needed for auto-code compilation)
 ******/


#include "osd_cdb_formats.h" //the auto-generated h file
#include "osd_attr_pages.h" //the auto-generated h file

/*********************************************************
 * from here parts after auto-code include
 * (using auto-code defs)
 ******/

/*manual post defs*/
#define OSD_GET_ATTR_NUMBERS(f,page_num,attr_num) \
do { (page_num)=OSD_ATTR_PAGE_NUM(f); (attr_num)=OSD_ATTR_NUM(f); } while(0)

#define OSD_PAGE_NUM(s) ((s)->num)
//#define OSD_PAGE_NAME(s) ((s)->name)
#define OSD_PAGE_ID(s) ((s)->name)
#define OSD_PAGE_IS_PF_ENABLED(s) ((s)->pf_enabled)
#define OSD_PAGE_PF_SIZE(s) ((s)->page_size)
#define OSD_PAGE_STRUCT_SIZE(s) ((s)->struct_size)

#define OSD_ATTR_SIZE(f) ((f)->size)
#define OSD_ATTR_OFFSET(f) ((f)->offset)
#define OSD_ATTR_PAGE_NUM(f) ((f)->page_num)
#define OSD_ATTR_NUM(f) ((f)->num)
#define OSD_ATTR_NAME(f) ((f)->name)
#define OSD_ATTR_ACCESS(f) ((f)->access)
#define OSD_ATTR_IS_INTEGER(f) (((f)->type_num)!=uint8_en)

#define OSD_ATTR_IS_PG_LEN(f) (0==strcmp("page_length",f->name))
#define OSD_ATTR_IS_PG_ID(f) (0==strcmp("page_id",f->name))

gen_struct_t * OSD_FIND_PAGE(uint32_t NUM);
gen_field_t * OSD_FIND_ATTR(uint32_t PAGE_NUM,uint32_t ATTR_NUM);


/******************************************
 * others
 */

#ifndef UINT16_MAX
#define UINT16_MAX ((1<<16)-1)
#endif

#define IS_IN_MASK(val,mask) (((mask)|(val))==(mask))

#define SET_MASKED_VAL(var,mask,val) \
do { (var)=(((var)&(~(mask)))|((val)&(mask))); \
     osd_assert(IS_IN_MASK(val,mask));} while(0)

#define MAKELONG(byte3,byte2, byte1, byte0) \
  ( (byte3*(1<<24))+(byte2*(1<<16))+(byte1*(1<<8))+byte0)

static uint64_t gen_NTOH_offset(offset32_t cdb_offset) {
    uint8_t exp;
    uint32_t mantissa;
    uint64_t tmp;
    uint8_t *pcdb_ofs;

    pcdb_ofs=(uint8_t *)&cdb_offset;

    if (OFFSET_IGNORE==cdb_offset) {
	OSD_TRACE(OSD_TRACE_T10,3,"decoded offset 0xFFFFFFFF=IGNORE\n");
	return OFFSET_IGNORE;
    }

    exp=8+(pcdb_ofs[0]>>4);
    tmp=(pcdb_ofs[0]&0x0F);
    mantissa=MAKELONG(tmp,pcdb_ofs[1],pcdb_ofs[2],
		      pcdb_ofs[3]);
    tmp = mantissa<<exp;

    if (tmp>((uint64_t)1<<31)) {
	OSD_TRACE(OSD_TRACE_T10,1,"too big offset calculated - ignored\n");
	return OFFSET_IGNORE;
    }
    OSD_TRACE(OSD_TRACE_T10,3,"decoded ofs %llu\n",tmp);
    return tmp;
}

static offset32_t gen_HTON_offset(uint64_t offset_val) {
    uint8_t exp;
    uint32_t mantissa;
    uint8_t *pcdb_ofs;
    uint32_t tmp;
    
    OSD_TRACE(OSD_TRACE_T10,3,"encoding ofs %llu\n",offset_val);
    
    if (OFFSET_IGNORE==offset_val) {
	return OFFSET_IGNORE;
    }

    if (offset_val==0) {
	return 0;
    }

    if (offset_val>(uint64_t)(1<<31)) {
	OSD_ERROR("big offset given\n");
	osd_assert(0);
	return OFFSET_IGNORE;
    }

    /*calculate exponent (NOTE: maximum exponent usable is calculated here)*/
    exp=7;
    while ( (exp<16) && ((offset_val&((1<<(exp+1))-1))==0) ) {
	exp++;
    }
    if (exp==16) exp=15;

    if (exp==7) {/*offset_val given cannot be represented*/
	OSD_ERROR("bad offset value given. offset must devide by 256  in standard\n");
	osd_assert(0);
	return OFFSET_IGNORE;
    }

    mantissa = offset_val>>exp;

    if (mantissa>((1<<28)-1)) {
	OSD_ERROR("too big offset given\n");
	osd_assert(0);
	return OFFSET_IGNORE;
    }
    
    pcdb_ofs=(uint8_t*)&tmp;

    /*start with mantissa part, then override exponent part only*/
    tmp = HTONL(mantissa);
    SET_MASKED_VAL(pcdb_ofs[0],0xF0,(exp-8)<<4);
    //PRINT("ofs coded %x %x %x %x\n",pcdb_ofs[0],pcdb_ofs[1],pcdb_ofs[2],pcdb_ofs[3]);
    return tmp;
}

#define OSD_BASE_OBJ_ID 0x10000

static void osd_valid_id(uint64_t id,
				const char* sname,const char*fname)
{
    if (id<OSD_BASE_OBJ_ID) {
	OSD_TRACE(OSD_TRACE_T10,1,
		  "%s.%s value(%llx) is illegal\n",sname,fname,id);
    }
}
static void osd_valid_or_zero_id(uint64_t id,
				    const char* sname,const char*fname)
{
    if ((id!=0) && (id<OSD_BASE_OBJ_ID)) {
	OSD_TRACE(OSD_TRACE_T10,1,
		  "%s.%s value(%llx) is illegal\n",sname,fname,id);
    }
}

static inline void osd_valid_sec_method(uint8_t sec_method,
					const char* sname,const char*fname)
{
    if (sec_method>0x3) {
	OSD_TRACE(OSD_TRACE_T10,1,
		  "%d is an invalid value for %s.%s\n",sec_method,sname,fname);
    }
}

static inline void osd_str_pad_copy(
    char*dst,const char*src, int length, char pad)
{
    int n;
    osd_assert(dst);
    osd_assert(src);
    n=strlen(src);
    strncpy(dst,src,length);
    if (length>n) memset(&(dst[n]),pad,length-n);
}

static inline void osd_str_unpad_copy(
    char*dst,const char*src, int length, char pad)
{
    int i;
    osd_assert(dst);
    osd_assert(src);
    for (i=0;i<length;i++) {
	if (pad==(dst[i]=src[i])) break;
    }
    dst[i]='\0';
}


#endif /*ifndef OSD_FORMATS_H*/
